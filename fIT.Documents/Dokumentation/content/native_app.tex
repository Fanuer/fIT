\chapter{Realisierung der clientseitigen Implementierung als native App}
\label{cha:native-app}
Dieses Kapitel widmet sich der Implementierung der nativen Applikation. Im Kapitel \ref{cha:architektur} wurde eine grobe Übersicht zu der Umsetzung und der Funktionsweise dieser \ac{App} gegeben, die nun verfeinert wird.
Dabei werden folgend die verwendeten Komponenten und Techniken erläutert und die Zusammenhänge zwischen den Techniken dargestellt.
\section{Allgemeine Funktionsweise einer Android-App}
\label{sec:definition-android}
Grundlegend für die Entwicklung einer Android-App ist das Wissen über die Basis des Systems, auf dem entwickelt wird. 
Bei dem Betriebssystem \ac{Android} handelt es sich um eine Art eines \ac{monolithisch}en Multiuser-\ac{Linux}-Systems. \footcite{Android-Fundamentals}
Dieses Betriebssystem stellt die Hardwaretreiber zur Verfügung und führt die Prozessorganisation, sowie die Benutzer- und Speicherverwaltung durch.
Jede Applikation wird in einem eigenen Prozess gestartet. In diesem Prozess befindet sich eine \ac{Sandbox}, die eine virtuelle Maschine mit der Applikation ausführt. Die Kommunikation aus der Sandbox heraus kann nur über Schnittstellen des Betriebssystems geschehen. Diese Einschränkung sorgt für Sicherheit im System, da ein Prinzip der minimalen Rechte eingehalten wird. Demnach kann eine Applikation nur auf zugewiesene und freigegebene Ressourcen im System zugreifen. Ein weiterer Vorteil dieser internen Architektur liegt in der Robustheit des Systems. Wenn eine Applikation durch Fehler terminiert, wird nur der allokierte Prozess beendet und das Betriebssystem bleibt von diesem Problem unberührt. \footcite{Android-SystemPermissions}
Android-Applikationen werden in der Programmiersprache \ac{Java} geschrieben, mit einem Java-\ac{Compiler} kompiliert und dann von einem Cross-Assembler für die entsprechende \ac{VM} aufbereitet. Das Produkt ist ein ausführbares \ac{.apk}-Paket.\footcite[Seite 17-19]{Android-BeckerPant}
Im Folgenden werden die Android-Komponenten, die für die Umsetzung relevant sind, genauer betrachtet.
\subsection{User Interfaces}
\label{ssec:android-ui}
\textit{User Interfaces} sind die Bildschirmseiten der Android-Applikation. Über diese Seiten wird die Benutzerinteraktion geführt. Das \textit{User Interface} besteht aus zwei Arten von Elementen. Zum einen aus \textit{Views}, die es ermöglichen direkte Interaktionen mit dem Benutzer zu führen. Zu nennen sind dabei \textit{Buttons}, Textfelder und Checkboxen. Als zweites werden \textit{View Groups} verwendet, um \textit{Views} sowie andere \textit{View Groups} anzuordnen.
Das \textit{User Interface Layout} ist durch eine hierarchische Struktur gekennzeichnet. Zum Anlegen einer solchen Struktur gibt es verschiedene Möglichkeiten. Zum einen kann man ein \textit{View}-Objekt anlegen und darauf die Elemente platzieren. Aus Gründen der Performance und der Übersicht ist die Möglichkeit einer \ac{XML}-Datei jedoch zielführender. Aus den Knoten der erstellten Datei werden zur Laufzeit \textit{View}-Objekte erzeugt und angezeigt. Die erzeugten \textit{UIs} werden unter \textit{res/layout} im Android-Betriebssystem hinterlegt. Des Weiteren können Ressourcen in den \textit{UIs} verwendet werden. Unter Ressourcen versteht man Elemente, die zum Verzieren von Oberflächen verwendet werden können. Darunter fallen bespielsweise Grafiken oder \textit{Style-Sheets}, die über den jeweiligen Ressourcen-Schlüssel aufgerufen und verwendet werden.\footcite{Android-UI}
\subsection{Activities}
\label{ssec:android-activities}
\textit{Activities} gehören zu den App-Komponenten, da sie ein grundsätzlicher Bestandteil einer Applikation sind. Es gibt im Normalfall mehrere \textit{Activities} in einer App.\\
Die eigentlichen Aufgaben liegen in der Bereitstellung eines Fensters, das dann auf den Screen, der für die App vom Betriebssystem bereitgestellt wird, gelegt wird. Das Fenster ist im Anschluss für die Annahme von Benutzerinteraktionen bereit. Das Fenster wird mit Hilfe des Aufrufs \textit{SetContentView()} aufgerufen. Zur Benutzerinteraktion werden dann die bereits vorgestellten \textit{View}-Elemente verwendet. Die \textit{Activity} ist folgend für die Verarbeitung und Auswertung der Eingaben verantwortlich.\\
In jeder Applikation muss es eine \textit{MainActivity} geben, die beim Start der Applikation vom Android-Betriebssystem gestartet wird. Zudem muss eine \textit{Activity} im AndroidManifest mit dem Attribut \textit{Launcher} versehen werden, um diese dann als Einstiegspunkt aus dem Menü des Betriebssystems zu setzen. Dabei ist empfehlenswert, dass dieselbe \textit{Activity} sowohl das Main- als auch Launcher-Attribut erhält.\\
Diese Festlegungen müssen im Manifest hinterlegt werden. Das Manifest liegt im Root-Ordner der App und stellt dem Betriebssystem wichtige Informationen der Applikation zur Verfügung. Dieses Manifest wird vor Ausführung der App analysiert und ausgewertet. Darin kann beispielweise festgelegt werden, welche Komponenten oder anderen Applikationen auf entsprechende \textit{Activities} zugreifen dürfen. Wenn eine \textit{Activity} nicht von außerhalb der App erreicht werden soll, sollte kein Intent-Filter gesetzt werden, da demnach der genaue Name der \textit{Activity} zum Start bekannt sein muss. Diese Informationen sind jedoch nur in der gegenwärtigen App vorhanden.\\
Da eine App normalerweise aus mehreren \textit{Activities} besteht, müssen diese \textit{Activities} gestartet werden und untereinander kommunizieren. \textit{Activities} starten sich gegenseitig, weshalb der Aufruf einer \textit{Activity} aus einer anderen erfolgt. Um eine neue \textit{Activity} starten zu können, ist ein Intent von Nöten.
Ein Intent ist ein Nachrichtenobjekt innerhalb von Android, welches zur Kommunikation zwischen App-Komponenten verwendet wird. In diesem Fall zwischen zwei \textit{Activities}. Zur Erstellung benötigt es den Namen der zu startenden Komponente, um eine Verbindung dorthin aufbauen zu können, und eine \textit{Action}, die ausgeführt werden soll. Zudem können Daten übergeben werden, die anschließend als Datenpakete mit dem Aufruf der Komponente mitgegeben werden. Diese Daten sind dann in der gestarteten Komponente aus dem dort vorhandenen Intent auslesbar. Zusätzlich gibt es die Möglichkeit Aktionen vom Betriebssystem ausführen zu lassen. Beispielsweise kann man ein \textit{Intent} mit der Aktion zum Starten des Email-Programms übergeben und die entsprechend im Betriebssystem hinterlegte Applikation zum schreiben von Emails wird geöffnet.\\
Eine \textit{Activity} kann drei Stati in einem \textit{Lifecycle} einnehmen. Zum einen kann die \textit{Activity} im Status \textit{Resumed} - oft auch \textit{Running} genannt - sein und damit momentan im User-Fokus stehen, also im Vordergrund der App sein und die Interaktionen entgegennehmen. Des Weiteren kann eine \textit{Activity} pausieren, wenn eine andere im User-Fokus steht. Dabei ist der \textit{View} der betrachteten \textit{Activity} jedoch immer noch teilweise sichtbar, da der darüberliegende \textit{View} zu Beispiel nicht den gesamten Bildschirm in Anspruch nimmt. Anders verhält es sich, wenn der \textit{View} der betrachteten \textit{Activity} komplett überdeckt ist. Dann befindet sich die \textit{Activity} nämlich im Status \textit{Stopped}. Sowohl im Status \textit{Stopped} als auch im Status \textit{Paused} lebt die \textit{Activity} noch. Das bedeutet, dass das \textit{Activity}-Objekt zusammen mit allen Objekt-Stati und Memberinformationen im Arbeitsspeicher liegt. Der einzige Unterschied dieser beiden Stati liegt darin, dass eine \textit{Activity} im Status \textit{Paused} noch eine Verbindung zum \textit{WindowManager} besitzt, die im Status \textit{Stopped} nicht mehr vorhanden ist. Gemeinsam haben diese beiden Stati jedoch noch, dass sie bei mangelndem Arbeitsspeicher vom Betriebssystem zerstört werden können. 
%ActivityLifecycle-Bild
\begin{figure}[h]
\centering
\includegraphics[width=0.8\linewidth]{content/images/Android-ActivityLifecycle}
\caption{Android Activity-Lifecycle}
Quelle: https://developer.android.com/guide/components/activities.html
\label{pic:androidActivityLifecycle}
\end{figure}
Die Ausführung der internen Methoden einer \textit{Activity} ist abhängig von den Eingaben des Benutzers. Dabei durchläuft jede \textit{Activity} ihren \textit{Lifecycle}, der in Abbildung~\ref{pic:androidActivityLifecycle} dargestellt ist. Darin ist zu erkennen, dass zuerst die \textit{OnCreate()}-Methode aufgerufen wird. Darin werden alle essentiellen Initialisierungen gemacht und der \textit{View} aufgerufen. Nachfolgend werden \textit{OnStart()} und \textit{OnResume()} durchlaufen bis die \textit{Activity} den User-Fokus wieder verliert, jedoch der \textit{View} noch sichtbar ist. In dem Moment wird die \textit{OnPause()}-Methode ausgeführt, um Benutzereingaben gegebenenfalls speichern zu können, denn in diesem Zustand ist es in seltenen Fällen möglich, dass der Status - wie oben erklärt - durch das Betriebssystem zerstört wird. Kehrt der Benutzer zurück, wird \textit{OnResume()} wieder aufgerufen, sonst \textit{OnStop()}, um auch dort aufgenommene Daten persitieren zu können. Von dort gibt es zwei verschiedene Rücksprung-Möglichkeiten. Zum einen könnte der Fall eintreten, dass die Daten der \textit{Activity} aus dem Arbeitsspeicher gelöscht wurden, die \textit{Activity} jedoch noch einmal aufgerufen wird. In diesem Fall startet die \textit{Activity} wieder von vorn. Eine weitere Möglichkeit ist die Rückkehr des Benutzers zu der \textit{Activity}. Dabei werden dann die Methoden \textit{OnRestart()} und \textit{OnStart()} aufgerufen.\\
Zusammenfassend lässt sich daraus ableiten, dass die Persistierung von Eingaben in den Methoden \textit{OnPause()}, \textit{OnStop()} und \textit{OnDestroy()} durchgeführt werden sollten, da diese Zustände zerstört werden können. Die weiteren Methoden sollten aus Performancegründen jedoch minimal und agil gehalten werden.
\subsection{Services}
\label{ssec:android-services}
\textit{Services} sind, genauso wie \textit{Activities}, App-Komponenten, die zu den Grundbausteinen einer Android-App gehören. \textit{Services} unterscheiden sich jedoch hinsichtlich ihrer Aufgaben stark von \textit{Activities}. So sind sie dazu da, Aufgaben im Hintergrund zu erledigen. Zudem besitzen sie keinen zugehörigen \textit{View}, sondern werden von anderen App-Komponenten, wie beispielsweise einer \textit{Activity} gestartet. Sie laufen im \textit{Main-Thread} des Prozesses der aufrufenden Komponente. Ein \textit{Service} erstellt keinen eigenen \textit{Thread}, noch einen eigenen Prozess zur Abarbeitung der Aufgaben. Diese Eigenschaft der \textit{Services} muss vom Entwickler bedacht werden. Denn daraus kann man ableiten, dass rechenintensive Aufgaben in einem explizit gestarteten \textit{Thread} arbeiten sollten, um Fehler der Art \textit{Application Not Rsponding} (ANR) zu vermeiden und die Benutzeroberfläche nicht unnötig zu verlangsamen. Ein Vorteil besteht jedoch darin, dass \textit{Services} Aufgaben auch dann noch ausführen können, wenn die App, zu der sie gehören, geschlossen wurde. So können noch nicht abgeschlossene \textit{Up-} oder \textit{Downloads} noch beendet werden oder das Abspielen von Musik bei ausgeschaltetem Bildschirm fortgeführt werden.\\
Bei Android wird grundsätzlich zwischen zewi Arten von \textit{Services} unterschieden. Zum einen gibt es \textit{Started-Services}, die durch eine App-Komponente mit dem Befehl \textit{StartService()} gestartet werden. Grundsätzlich ist dieser Aufruf uneingeschränkt von allen App-Komponenten möglich, soweit die Einstellungen im Android-Manifest diese zulassen. Weiterhin laufen \textit{Started-Services} im Hintergrund der App weiter, auch wenn die Komponente, die den \textit{Service} gestartet hat, zerstört oder beendet wurde. Deshalb führt diese Art des \textit{Services} im Normalfall eine Aufgabe aus und stoppt sich anschließend nach der Fertigstellung selbstständig. Auf der anderen Seite gibt es \textit{Bound-Services}, die durch einen Aufruf von \textit{BindServcice()} einer anderen App-Komponente gestartet werden. In diesem Schritt verbinden sich die Komponente und der \textit{Service} über eine Art \textit{Client-Server Interface}, das zur Kommunikation bereitgestellt wird. Dieses \textit{Interface} ist vom Typ \textit{IBind} und sorgt für den Austausch von \textit{Request} und \textit{Results}. Des Weiteren verläuft eine mögliche Interprozess-Kommunikation zwischen Komponente und \textit{Service} über dieses \textit{Interface}. Die größte Besonderheit eines \textit{Bound-Services} besteht darin, dass der \textit{Service} nur so lange besteht, wie mindestens eine Komponente an diesen gebunden ist. Natürlich ist es möglich, dass sich mehrere Komponenten gleichzeitig an diesen \textit{Service} binden können. Löst sich jedoch die letzte Komponente wieder, wird der \textit{Service} zerstört. Natürlich gibt es Mischformen dieser beiden \textit{Service}-Arten, die abhängig von der zu leistenden Aufgabe gewählt werden sollten. 
%ServiceLifecycle-Bild
\begin{figure}[h]
\centering
\includegraphics[width=0.8\linewidth]{content/images/Android-ServiceLifecycle}
\caption{Android Service-Lifecycle}
Quelle: https://developer.android.com/guide/components/services.html
\label{pic:androidServiceLifecycle}
\end{figure}
Zum Erstellen eines \textit{Services} muss von der Klasse \textit{Service}, oder davon abgeleitete Klassen, geerbt werden. Danach müssen die vorgegebenen Methoden überschrieben werden, denn \textit{Services} besitzen, genauso wie \textit{Activities}, einen Lebenszyklus. Dabei muss jedoch wieder zwischen den beiden Arten von \textit{Services} unterschieden werden.\\
\textit{Started-Services} werden die Methode \textit{OnCreate()} nach dem Start durch eine Komponente ausführen, wenn der \textit{Service} noch nicht läuft. Darin sollten dann die Initialisierungen und einmaligen Aufgaben zum Start des \textit{Services} durchgeführt werden. \textit{OnStartCommand()} wird immer dann aufgerufen, wenn der \textit{Service} wieder von einer Komponente aufgerufen wird. Dann befindet er sich im Zustand \textit{Running} und führt die ihm zugewiesenen Aufgaben durch. Wenn der \textit{Service} zerstört wird, sei es durch Speichermangel des \textit{Devices} oder das Beenden durch eine Komponente oder den \textit{Service} selbst, wird \textit{OnDestroy()} ausgeführt, um abschließende Aufgaben durchzuführen. Dazu zählen beispielsweise das Beenden von Datenbankverbindungen oder \textit{Threads}.\\
\textit{Bound-Services} werden, wie oben genannt, über \textit{BindService()} von einer Komponente gestartet und führen dann, genauso wie die \textit{Started-Services}, die \textit{OnCreate()}-Methode zum Initialisieren aus. Gefolgt vom aktiven Status, in dem anfangs \textit{OnBind()} aufgerufen wird und die von den Komponenten verlangten Aufgaben ausgeführt werden. Anschließend lösen sich die Komponenten wieder vom \textit{Service}. Haben sich alle Komponenten gelöst, wird auch beim \textit{Bound-Service} \textit{OnDestroy()} ausgeführt.
\subsection{Prozesse und Threads}
\label{ssec:android-prozesse-threads}
Sobald eine Applikation gestartet wird, und keine Komponenten daraus bereits laufen, wird vom Android-Betriebssystem ein neuer Prozess mit einem dazugehörigen \textit{Main-Thread} erzeugt. Standardmäßig werden alle Operationen dieser App in diesem Prozess und diesem \textit{Thread} ausgeführt. Laufen Teile einer Applikation jedoch noch im Hintergrund, wie es bei Services möglich ist (siehe \ref{ssec:android-services}), und die App wird vom Benutzer erneut gestartet, so wird diese Komponente in dem noch bestehenden Prozess und \textit{Thread} eingepflegt.\\
Es gibt jedoch auch die Möglichkeit verschiedene App-Komponenten auf mehrere Prozesse zu verteilen. Dazu genügt ein Eintrag im Android-Manifest. Dadurch ist es dann auch möglich Komponenten verschiedener Applikationen in einem Prozess laufen zu lassen. Voraussetzung dafür ist, dass diese beiden Applikationen mit demselben Zertifikat generiert wurden und dieselbe Linux \textit{\ac{user ID}} besitzen.\\
Prozesse können aber auch durch das Betriebssystem zerstört werden, wenn die Geräte-Ressourcen sich zum Beispiel dem Ende neigen und neue freigegeben werden müssen. Hierzu gliedert Android die Prozesse in eine Hierarchie ein und beendet die Prozesse, die zum Beispiel vom Benutzer seit längerer Zeit nicht mehr verwendet wurden oder keinen direkten Kontakt zur aktuellen Anzeige besitzen.\\
Der angesprochene \textit{Main-} oder auch \textit{\ac{UI-Thread}} beim Starten einer App, ist der Hauptakteur für die Kommunikation mit dem Betriebssystem. So werden alle Aufrufe an die Komponenten des \textit{Android UI toolkits} über diesen \textit{Thread} abgewickelt. Demnach müssen über diesen \textit{Thread} alle \textit{Callback}-Methoden von Systemeigenschaften, wie \textit{OnClick()}, darin bearbeitet werden. Daraus ergibt sich, dass aufwendige Aufgaben, die zum Beispiel Netzwerkverbindungen verwenden, in andere \textit{Threads} verlagert werden sollten, um dem Benutzer eine Oberfläche ohne lästige Wartezeiten zu ermöglichen. Einzige Einschränkung dabei ist, dass niemals von einem anderen \textit{Thread} als dem \textit{UI-Thread} auf \textit{\ac{Android UI toolkits}} zugegriffen werden darf. Diese Limitierung muss bei der Implementierung beachtet werden.\\
Zum Umgehen dieser Problematik können asynchrone \textit{\ac{Tasks}} verwendet werden, die Aufgaben außerhalb des \textit{UI-Threads} ausführen. Auf das Ergebnis dieser Ausführungen kann dann wieder zugegriffen werden. Diese Umsetzung bietet einen leichteren Umgang mit \textit{Multithreading} für den Entwickler und genießt deshalb immer größere Beliebtheit.
\subsection{SQLite}
\label{ssec:android-sqlite}
SQLite ist eine in sich geschlossene und serverlose \ac{SQL}-Datenbank. Sie besteht aus einer \textit{In-Process}-Bibliothek, die es ermöglicht eine Datenbank ohne eigenen Server-Prozess zu betreiben. Dabei liegt die Datenbank mitsamt aller Tabellen, \textit{Views} und \textit{\ac{Trigger}} in einer einzigen Datei vor. Diese Datei ist zudem so konzipiert, dass sie plattformübergreifend zwischen 32- und 64-Bit-Systemen kopiert werden kann. Weitere Vorteile von SQLite liegen in der sehr sparsamen Speicherung der Daten und der, durch die gemeinfreie Lizenz, große Unterstützung durch Drittanbieter-Programmen. So gibt es für alle gängigen mobilen Systeme eine meist schon integrierte Unterstützung von SQLite-Datenbanken. Android unterstützt diese Datenbankart als präferierte Datenhaltung.
\section{Was ist Xamarin Platform?}
\label{sec:defintion-xamarin}
Xamarin Platform ist ein Produkt der Firma Xamarin, die ihren Sitz in San Francisco hat. Diese Firma entwickelt Software für die Erstellung von nativen Apps auf Basis des \textit{Open Source}-Projekts \ac{Mono}. Mono seinerseits hat mehrere Vorteile:
\begin{itemize}
\item \textbf{Popularität}\\Es kann auf die Erfahrung von Millionen C\# -Entwicklern zurückgegriffen werden.
\item \textbf{Höhere Programmiersprache} \\Es können die Vorteile von höheren Programmiersprachen verwendet werden. Zu nennen sind dabei besonders \textit{Threading}, automatische Speicherverwaltung und \textit{\ac{Reflection}}.
\item \textbf{Klassenbibliotheken}\\Die Verwendung von bestehenden Klassenbibliotheken erleichtern das Umsetzen komplexer Aufgaben.
\item \textbf{\textit{Cross-Platform}}\\Die fertiggestellte Software kann auf fast allen Systemen verwendet werden.
\end{itemize}
Damit können plattfomunabhängige Programme in C\# programmiert werden. Beliebtheit erlangte Mono mit dem Wunsch von Entwicklern Apps auf verschiedenen mobilen Betriebssystemen bereitstellen zu können und dabei Änderungen und die Entwicklung größtmöglich zu vereinen. Genau diese Wünsche werden mit \textit{Xamarin Platform} erfüllt. Vorher war es immer nötig drei Applikationen für die verbreitetsten mobilen Betriebssysteme zu entwickeln. Dies bedeutete, dass die \textit{Guidlines} der jeweiligen Systeme iOS, Android und Windows Phone analysiert und in den jeweiligen Programmiersprachen umgesetzt werden mussten.
\subsection{Multiplattform-Unterstützung}
\label{ssec:xamarin-multiplattform}
%Xamarin-Platform-Bild
\begin{figure}[h]
\centering
\includegraphics[width=\linewidth]{content/images/Xamarin-Platform}
\caption{Xamarin Platform}
Quelle: http://xamarin.com/platform
\label{pic:xamarinPlatform}
\end{figure}
Durch Xamarin Platform ist es möglich alle Funktionalitäten der gewünschten Betriebssysteme in vollem Umfang zu verwenden. Diese Tatsache liegt daran, dass erstellte Projekte in die nativen Sprachen des Systems überführt und dann normal kompiliert werden. Durch die Nutzung der Standard-Steuerelemente eines jeden Betriebssystems sorgt dafür, dass die Benutzer keinen Unterschied zu einer App erkennen können, die ausschließlich für ein Betriebssystem entwickelt wurde. Auch plattformspezifische Funktionen können verwendet werden. Zudem werden alle Vorteile der Programmiersprache C\# ausgenutzt.\footcite{Xamarin-Platform} So ist der Umgang mit asynchronen Funktionen in dieser Sprache zum heutigen Stand am besten gelöst. Des Weiteren können \textit{Shared Projects} zur Entwicklung verwendet werden, sowie \ac{PCL}s und \textit{\ac{NuGet}}-Pakete eingebunden werden, um den Funktionsumfang schnell und einfach erweitern zu können.\footcite{Xamarin-Multiplatform}
\subsection{Besonderheiten der Android-Umsetzung}
\label{ssec:xamarin-android}
Bei der Entwicklung einer Android-App mit Hilfe von Xamarin Platform vereint man die Vorteile zweier Systeme. Zum einen hat man den Vorteil der freien und starken Entwicklungsumgebung Visual Studio in Kombination mit C\#, zum anderen kann man alle Besonderheiten der Android-Entwicklung einbeziehen und verwenden.\\
So muss man am Anfang der Entwicklung auswählen, welche Android-\ac{API} als Minimalvoraussetzung verwendet werden soll und welche Version vorrangig unterstützt werden soll. Zweifellos ist es möglich die von dem \textit{Device} verwendete Android-Version abzufragen und dementsprechend die Funktionalität der App anzupassen.
Zudem können \textit{Java-Packeges} eingebunden und verwendet werden, um bekannte Funktionen auch in C\# verwenden zu können.\\
Eine sehr große Unterstützung ist das automatische Führen des Android-Manifestes. Dabei werden zwar nur rudimentäre Einstellungen aus der Entwicklung übernommen, aber auch diese Unterstützung ist für Neulinge auf dem Gebiet der Android-Entwicklung eine gute Beihilfe.
\subsection{Android Emulator}
\label{ssec:xamarin-emulator}
Zum Testen der Android-App konnte ein Emulator verwendet werden, der in dem Xamarin-Plugin für Visual Studio bereitgestellt wurde. Damit konnten dann verschiedene Szenarien, wie Verbindungsverlust oder Speicherknappheit, nachgestellt werden. Für die App wurde das Android-API-Level 19 als Minimal- und \textit{Target}-Anforderung gewählt. Dies steht für Android 4.4 mit dem Namen Kitkat. Damit sollte eine große Abdeckung von Android-Geräten bewerkstelligt werden.\footcite{Xamarin-API}
\section{Eigene Umsetzung}
\label{sec:nat-umsetzung}


\subsection{Anlegen der Layouts}
\label{ssec:nat-layouts}

\subsection{Konnektivität zum Server}
\label{ssec:nat-konnektivität}

\subsection{Lokale Datenbank}
\label{ssec:nat-db}

\subsection{Umsetzung des Caches}
\label{ssec:nat-cache}
