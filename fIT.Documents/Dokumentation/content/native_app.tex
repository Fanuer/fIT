\chapter{Realisierung des Clients als native App}
\label{cha:native-app}
Dieses Kapitel widmet sich der Implementierung der nativen Applikation. Im Kapitel \ref{cha:architektur} wurde eine grobe Übersicht zu der Umsetzung und der Funktionsweise dieser \gls{App} gegeben, die nun konkretisiert wird.
Dabei werden nachfolgend die verwendeten Komponenten und Techniken erläutert und deren Zusammenhänge dargestellt.
\section{Allgemeine Funktionsweise einer Android-App}
\label{sec:definition-android}
Grundlegend für die Entwicklung einer \gls{Android}-App ist das Wissen über die Basis des Systems, auf dem entwickelt wird. 
Bei dem Betriebssystem \gls{Android} handelt es sich um eine Art eines \gls{monolithisch}en Multiuser-\gls{Linux}-Systems. \footcite{Android-Fundamentals}
Dieses Betriebssystem stellt die Hardwaretreiber zur Verfügung und führt die Prozessorganisation, sowie die Benutzer- und Speicherverwaltung durch.\footcite[S. 19ff.]{Android-BeckerPant}
Jede Applikation wird in einem eigenen Prozess gestartet. In diesem Prozess befindet sich eine \gls{Sandbox}, die eine virtuelle Maschine mit der Applikation ausführt. Die Kommunikation aus der Sandbox heraus kann nur über Schnittstellen des Betriebssystems geschehen. Demnach kann eine Applikation nur auf zugewiesene und freigegebene Ressourcen im System zugreifen. Ein weiterer Vorteil dieser internen Architektur liegt in der Robustheit des Systems. Wenn eine Applikation durch Fehler terminiert, wird nur der zugewiesene Prozess beendet und das Betriebssystem bleibt von diesem Problem unberührt. \footcite{Android-SystemPermissions}
\gls{Android}-Applikationen werden in der Programmiersprache \gls{Java} geschrieben, mit einem Java-\ac{Compiler} kompiliert und dann von einem Cross-Assembler für die entsprechende \ac{VM} aufbereitet. Das Produkt ist ein ausführbares \ac{.apk}-Paket.\footcite{Android-Fundamentals}
Im Folgenden werden die \gls{Android}-Komponenten, die für die Umsetzung relevant sind, genauer betrachtet.
\subsection{User Interfaces}
\label{ssec:android-ui}
\textit{User Interfaces} sind die Bildschirmseiten der \gls{Android}-Applikation. Über diese Seiten wird die Benutzerinteraktion geführt. Das \textit{User Interface} besteht aus zwei Arten von Elementen. Zum einen aus \textit{Views}, die es ermöglichen direkte Interaktionen mit dem Benutzer zu führen. Zu nennen sind dabei \textit{Buttons}, Textfelder und Checkboxen. Als zweites werden \textit{View Groups} verwendet, um \textit{Views} sowie andere \textit{View Groups} anzuordnen.\footcite[S. 40f.]{Android-BeckerPant}\\
Das \textit{User Interface Layout} ist durch eine hierarchische Struktur gekennzeichnet. Zum Anlegen einer solchen Struktur gibt es verschiedene Möglichkeiten. Zum einen kann man ein \textit{View}-Objekt anlegen und darauf die Elemente platzieren. Aus Gründen der Performance und der Übersicht ist die Möglichkeit einer \ac{XML}-Datei jedoch zielführender. Aus den Knoten der erstellten Datei werden zur Laufzeit \textit{View}-Objekte erzeugt und angezeigt. Die erzeugten \textit{User Interface Layouts} werden unter \textit{res/layout} im \gls{Android}-Betriebssystem hinterlegt. Des Weiteren können Ressourcen in den \textit{User Interface Layouts} verwendet werden. Unter Ressourcen versteht man Elemente, die zum Verzieren von Oberflächen verwendet werden können. Darunter fallen beispielsweise Grafiken oder \textit{Stylesheets}, die über den jeweiligen Ressourcen-Schlüssel aufgerufen und verwendet werden.\footcite{Android-UI}
\subsection{Activities}
\label{ssec:android-activities}
\textit{Activities} gehören zu den App-Komponenten, da sie ein grundsätzlicher Bestandteil einer Applikation sind. Es gibt im Normalfall mehrere \textit{Activities} in einer App.\\
Die eigentliche Aufgabe liegt in der Bereitstellung eines Fensters, das dann auf den Bildschirm, der für die App vom Betriebssystem bereitgestellt wird, gelegt wird. Anschließend können Benutzerinteraktionen vom Fenster angenommen werden.\footcite[S. 40]{Android-BeckerPant} Das Fenster wird mit Hilfe von \textit{SetContentView()} aufgerufen. Zur Benutzerinteraktion werden dann die bereits vorgestellten \textit{View}-Elemente verwendet. In der \textit{Activity} werden folgend die Verarbeitung und Auswertung der Eingaben durchgeführt.\\
In jeder Applikation muss es eine \textit{MainActivity} geben, die beim Start der Applikation vom Android-Betriebssystem gestartet wird. Zudem muss eine \textit{Activity} im AndroidManifest mit dem Attribut \textit{Launcher} versehen werden, um diese dann als Einstiegspunkt in das Menü des Betriebssystems zu setzen. Dabei ist es empfehlenswert, dass dieselbe \textit{Activity} sowohl das Main- als auch Launcher-Attribut erhält, da es sinnvoll ist, dass die zuerst aufgerufene Seite einer App auch gleichzeitig die Startseite ist.\\
Das Manifest liegt im Wurzelverzeichnis der App und stellt dem Betriebssystem wichtige Informationen der Applikation zur Verfügung. Dieses Manifest wird vor Ausführung der App analysiert und ausgewertet. Darin kann beispielsweise festgelegt werden, welche Komponenten oder anderen Applikationen auf entsprechende \textit{Activities} zugreifen dürfen. Wenn eine \textit{Activity} nicht von außerhalb der App erreichbar sein soll, sollte kein sogenannter \textit{Intent}-Filter gesetzt werden.\\
Da eine App normalerweise aus mehreren \textit{Activities} besteht, müssen diese \linebreak gestartet werden und untereinander kommunizieren. \textit{Activities} starten sich gegenseitig, weshalb der Aufruf einer \textit{Activity} aus einer anderen erfolgt. Um eine neue \textit{Activity} starten zu können, ist ein \textit{Intent} von Nöten.\footcite[S. 135ff.]{Android-BeckerPant}
Ein \textit{Intent} ist ein Nachrichtenobjekt innerhalb von Android, welches zur Kommunikation zwischen App-Komponenten verwendet wird. In diesem Fall zwischen zwei \textit{Activities}. Zur Ansteuerung benötigt es den Namen der zu startenden Komponente, um eine Verbindung dorthin aufbauen zu können, und eine \textit{Action}, die ausgeführt werden soll. Zudem können Daten übergeben werden, die anschließend als Datenpakete mit dem Aufruf der Komponente mitgegeben werden. Diese Daten sind dann in der gestarteten Komponente aus dem dort vorhandenen Intent auslesbar. Zusätzlich gibt es die Möglichkeit Aktionen vom Betriebssystem ausführen zu lassen. Beispielsweise kann man einen \textit{Intent} mit der Aktion zum Starten des E-Mail-Programms übergeben. Daraufhin wird die Applikation geöffnet, die im Betriebssystem als Standard-E-Mail-Programm hinterlegt ist.\footcite{Android-Intent}\\
%ActivityLifecycle-Bild
\begin{figure}[!h]
\centering
\includegraphics[width=0.8\linewidth]{content/images/Android-ActivityLifecycle}
\caption{Android Activity-Lifecycle}
Quelle: https://developer.android.com/guide/components/activities.html
\label{pic:androidActivityLifecycle}
\end{figure}

Eine \textit{Activity} kann drei Status in einem \textit{Lifecycle} einnehmen. Zum einen kann die \textit{Activity} im Status \textit{Resumed} - oft auch \textit{Running} genannt - sein, momentan im Vordergrund der App sein und die Interaktionen entgegennehmen. Des Weiteren kann eine \textit{Activity} pausieren, wenn eine andere Oberfläche im User-Fokus steht. Dabei ist die \textit{View} der betrachteten \textit{Activity} jedoch immer noch teilweise sichtbar, da die darüberliegende \textit{View} zum Beispiel nicht den gesamten Bildschirm in Anspruch nimmt. Anders verhält es sich, wenn die \textit{View} der betrachteten \textit{Activity} komplett überdeckt ist. Dann befindet sich die \textit{Activity} nämlich im Status \textit{Stopped}. Die Abbildung \ref{pic:androidActivityLifecycle} zeigt die möglichen Übergänge zwischen den verschiedenen Status.\footcite{Android-Activities}\\
Essentiell ist die \textit{OnCreate}-Methode, in der Initialisierungen durchgeführten werden sollten und die View gestartet wird. Kehrt der Benutzer nach einer Bearbeitungspause zu der aktuellen \textit{Activity} zurück, wird \textit{OnResume} ausgeführt.\\
Die \textit{OnStop}-Methode sollte zur Persistierung von Daten verwendet werden und die darauf folgende Methode \textit{OnDestroy} alle Aufrufe eines Destruktors enthalten.\footcite[S. 289]{Android-BeckerPant}\\
Die Methoden sollten aus Performancegründen jedoch minimal und agil gehalten werden.
\subsection{Services}
\label{ssec:android-services}
\textit{Services} sind, genauso wie \textit{Activities}, App-Komponenten, die zu den Grundbausteinen einer \gls{Android}-\gls{App} gehören. \textit{Services} unterscheiden sich jedoch hinsichtlich ihrer Aufgaben stark von \textit{Activities}. So sind sie dazu da, Aufgaben im Hintergrund zu erledigen. Zudem besitzen sie keine zugehörige \textit{View}, sondern werden von anderen \gls{App}-Komponenten, wie beispielsweise einer \textit{Activity} gestartet.\footcite[S. 163]{Android-BeckerPant} Sie laufen im \textit{Main-Thread} des Prozesses der aufrufenden Komponente. Ein \textit{Service} erstellt weder einen eigenen \textit{Thread}, noch einen eigenen Prozess zur Abarbeitung der Aufgaben.\footcite{Android-Services} Diese Eigenschaft der \textit{Services} sollte vom Entwickler bedacht werden. Denn daraus kann man ableiten, dass rechenintensive Aufgaben in einem explizit gestarteten \textit{Thread} abgearbeitet werden sollten, um Fehler der Art \textit{\ac{ANR}} zu vermeiden und die Benutzeroberfläche nicht unnötig zu verlangsamen.\\
Ein weiterer Vorteil ist, dass \textit{Services} Aufgaben auch dann noch ausführen können, wenn die \gls{App}, zu der sie gehören, geschlossen wurde. So können noch nicht abgeschlossene \textit{Up-} oder \textit{Downloads} noch beendet werden oder das Abspielen von Musik bei ausgeschaltetem Bildschirm fortgeführt werden.\footcite[S. 161f.]{Android-BeckerPant}\\
Bei Android wird grundsätzlich zwischen zwei Arten von \textit{Services} unterschieden. Zum einen gibt es \textit{Started-Services}, die durch eine App-Komponente mit dem Befehl \textit{StartService()} gestartet werden. Grundsätzlich ist dieser Aufruf uneingeschränkt von allen App-Komponenten möglich, soweit die Einstellungen im \gls{Android}-Manifest diese zulassen. Weiterhin laufen \textit{Started-Services} im Hintergrund der App weiter, auch wenn die Komponente, die den \textit{Service} gestartet hat, zerstört oder beendet wurde. Deshalb führt diese Art des \textit{Services} im Normalfall eine Aufgabe aus und stoppt sich anschließend nach der Fertigstellung selbst.\\
Auf der anderen Seite gibt es \textit{Bound-Services}, die durch einen Aufruf von \textit{BindServcice} einer anderen App-Komponente gestartet werden. In diesem Schritt verbinden sich die Komponente und der \textit{Service} über eine Art \textit{Client-Server Interface}, das zur Kommunikation bereitgestellt wird. Dieses \textit{Interface} ist vom Typ \textit{IBind} und sorgt für den Austausch von \textit{Requests} und \textit{Results}. Eine weitere Besonderheit eines \textit{Bound-Services} besteht darin, dass der \textit{Service} nur so lange besteht, wie mindestens eine Komponente an diesen gebunden ist. Natürlich ist es möglich, dass sich mehrere Komponenten gleichzeitig an diesen \textit{Service} binden können. Löst sich jedoch die letzte Komponente wieder, wird der \textit{Service} zerstört.\footcite{Android-Services} 

%ServiceLifecycle-Bild
\begin{figure}[!h]
\centering
\includegraphics[width=0.5\linewidth]{content/images/Android-ServiceLifecycle}
\caption{Android Service-Lifecycle}
Quelle: https://developer.android.com/guide/components/services.html
\label{pic:androidServiceLifecycle}
\end{figure}

Zum Erstellen eines \textit{Services} muss von der Klasse \textit{Service}, oder davon abgeleitete Klassen, geerbt werden. Danach müssen die vorgegebenen Methoden überschrieben werden, denn \textit{Services} besitzen, genauso wie \textit{Activities}, einen Lebenszyklus. Dabei muss jedoch wieder zwischen den beiden Arten von \textit{Services} unterschieden werden.\footcite[S. 168f.]{Android-BeckerPant}\\
Die umrahmenden Methoden (grau dargestellte Elemente in der Abbildung \ref{pic:androidServiceLifecycle} außerhalb des gelben Bereichs) sollten, ähnlich zu den Methoden der \textit{Activities}, für die Initialisierung und Freigabe der verwendeten Komponenten sorgen. \textit{OnStartCommand()} wird immer dann aufgerufen, wenn der \textit{Service} wieder von einer Komponente aufgerufen wird. Dann befindet er sich im Zustand \textit{Running} und führt die ihm zugewiesenen Aufgaben durch. Wenn der \textit{Service} zerstört wird, sei es durch Speichermangel des Endgeräts, das Beenden durch eine Komponente oder den \textit{Service} selbst, wird \textit{OnDestroy()} ausgeführt.\\
\textit{Bound-Services} verhalten sich sehr ähnlich zu den \textit{Started-Services}, sind jedoch von dem Binden und Lösen von Komponenten abhängig und führen demnach die entsprechenden Methoden zur Ausführung ihrer Aktionen aus.\footcite{Android-Services}
\subsection{Prozesse und Threads}
\label{ssec:android-prozesse-threads}
Sobald eine Applikation gestartet wird, und keine Komponenten daraus bereits laufen, wird vom Android-Betriebssystem ein neuer Prozess mit einem dazugehörigen \textit{Main-Thread} erzeugt. Standardmäßig werden alle Operationen dieser App in diesem Prozess und diesem \textit{Thread} ausgeführt. Laufen Teile einer Applikation jedoch noch im Hintergrund, wie es bei Services möglich ist (siehe \ref{ssec:android-services}), und die App wird vom Benutzer erneut gestartet, so wird diese Komponente in dem noch bestehenden Prozess und \textit{Thread} eingepflegt.\\
Es gibt jedoch auch die Möglichkeit verschiedene App-Komponenten auf mehrere Prozesse zu verteilen. Dazu genügt ein Eintrag im Android-Manifest. Dadurch ist es dann auch möglich Komponenten verschiedener Applikationen in einem Prozess laufen zu lassen. Voraussetzung dafür ist, dass diese beiden Applikationen mit demselben Zertifikat generiert wurden und dieselbe Linux \textit{\gls{userID}} besitzen.\footcite{Android-ProcessesThreads}\\
Prozesse können aber auch durch das Betriebssystem zerstört werden, wenn die Geräte-Ressourcen zum Beispiel erschöpft sind und neue freigegeben werden müssen. Hierzu gliedert Android die Prozesse in eine Hierarchie ein und beendet die Prozesse, die zum Beispiel vom Benutzer seit längerer Zeit nicht mehr verwendet wurden oder keinen direkten Kontakt zur aktuellen Anzeige besitzen.\\
Der angesprochene \textit{Main-} oder auch \textit{UI-Thread} beim Starten einer App, ist der Hauptakteur für die Kommunikation mit dem Betriebssystem. So werden alle Aufrufe an die Komponenten des \gls{Android-UI-Toolkit} über diesen \textit{Thread} abgewickelt. Demnach müssen über diesen \textit{Thread} alle \textit{Callback}-Methoden von Systemeigenschaften, wie \textit{OnClick()}, darin bearbeitet werden. Daraus ergibt sich, dass aufwendige Aufgaben, die zum Beispiel Netzwerkverbindungen verwenden, in andere \textit{Threads} verlagert werden sollten, um dem Benutzer eine Oberfläche ohne Wartezeiten zu ermöglichen. Die einzige Einschränkung dabei ist, dass niemals von einem anderen \textit{Thread}, als dem \textit{UI-Thread}, auf die  \textit{\glspl{Android-UI-Toolkit}} zugegriffen werden darf. Dies muss bei der Implementierung bedacht werden.\footcite[S. 160f.]{Android-BeckerPant}\\
Asynchrone \textit{Tasks} können verwendet werden, um die Aufgaben außerhalb des \textit{UI-Threads} ausführen. Auf das Ergebnis dieser Ausführungen kann dann wieder zugegriffen werden.
\subsection{SQLite}
\label{ssec:android-sqlite}
SQLite ist eine in sich geschlossene und serverlose \ac{SQL}-Datenbank. Sie besteht aus einer \textit{In-Process}-Bibliothek, die es ermöglicht, eine Datenbank ohne eigenen Server-Prozess zu betreiben. Dabei liegt die Datenbank mitsamt aller Tabellen, \textit{Views} und \textit{\gls{Trigger}} in einer einzigen Datei vor. Diese Datei ist zudem so konzipiert, dass sie plattformübergreifend zwischen 32- und 64-Bit-Systemen kopiert werden kann. Weitere Vorteile von SQLite liegen in der sehr sparsamen Speicherung der Daten und der, durch die gemeinfreie Lizenz, große Unterstützung durch Drittanbieter-Programmen. So gibt es für alle gängigen mobilen Systeme eine meist schon integrierte Unterstützung von SQLite-Datenbanken. Android unterstützt diese Datenbankart als präferierte Datenhaltung.\footcite[S. 226f.]{Android-BeckerPant}
\section{Was ist \textit{Xamarin Platform}?}
\label{sec:defintion-xamarin}
Xamarin Platform ist ein Produkt der Firma Xamarin, die ihren Sitz in San Francisco hat. Diese Firma entwickelt Software für die Erstellung von nativen Apps auf Basis des \textit{Open Source}-Projekts \gls{Mono}. Mono seinerseits hat mehrere Vorteile:
\begin{itemize}
\item \textbf{Popularität}\\Es kann auf die Erfahrung von Millionen \gls{C-sharp} -Entwicklern zurückgegriffen werden.\footcite{Xamarin-Platform}
\item \textbf{Höhere Programmiersprache} \\Es können die Vorteile von höheren Programmiersprachen verwendet werden. Zu nennen sind dabei besonders \textit{Threading}, automatische Speicherverwaltung und \textit{\gls{Reflection}}.
\item \textbf{Klassenbibliotheken}\\Die Verwendung von bestehenden Klassenbibliotheken erleichtern das Umsetzen komplexer Aufgaben.
\item \textbf{\textit{Cross-Platform}}\\Die fertiggestellte Software kann auf allen gängigen Systemen verwendet werden.
\end{itemize}
Damit können plattfomunabhängige Programme unter anderem in \gls{C-sharp} programmiert werden.\footcite{Xamarin-Multiplatform} Dieser Bedarf wird mit \textit{Xamarin Platform} erfüllt. Vorher war es immer nötig drei Applikationen für die verbreitetsten mobilen Betriebssysteme zu entwickeln. Nun wird die Funktionalität plattformunabhängig umgesetzt und darauf plattformspezifische Anpassungen gemacht. Die \textit{UI-Guidelines} des jeweiligen Betriebssystems müssen weiterhin eingehalten werden.\footcite{Xamarin-Platform}
\subsection{Multiplattform-Unterstützung}
\label{ssec:xamarin-multiplattform}

%Xamarin-Platform-Bild
\begin{figure}[!h]
\centering
\includegraphics[width=\linewidth]{content/images/Xamarin-Platform}
\caption{Xamarin Platform}
Quelle: http://xamarin.com/platform
\label{pic:xamarinPlatform}
\end{figure}

Durch Xamarin Platform ist es möglich alle Funktionalitäten der gewünschten Betriebssysteme in vollem Umfang zu verwenden. Diese Tatsache liegt daran, dass erstellte Projekte in die nativen Sprachen des Systems überführt und dann normal kompiliert werden. Durch die Nutzung der Standard-Steuerelemente eines jeden Betriebssystems sorgt dafür, dass die Benutzer keinen Unterschied zu einer App erkennen können, die ausschließlich für ein Betriebssystem entwickelt wurde. Auch plattformspezifische Funktionen können verwendet werden. Zudem werden alle Vorteile der Programmiersprache C\# ausgenutzt.\footcite{Xamarin-Platform} So ist die Unterstützung von asynchronen Funktionen in dieser Sprache vollständig umgesetzt. Des Weiteren können \textit{Shared Projects} zur Entwicklung verwendet werden, sowie \ac{PCL}s und \textit{\gls{NuGet}}-Pakete eingebunden werden, um den Funktionsumfang erweitern zu können.\footcite{Xamarin-Multiplatform}
\subsection{Besonderheiten der Android-Umsetzung}
\label{ssec:xamarin-android}
Bei der Entwicklung einer Android-App mit Hilfe von Xamarin Platform vereint man die Vorteile zweier Systeme. Zum einen hat man den Vorteil der Reife von \textit{Visual Studio} in Kombination mit C\#, zum anderen kann man alle Besonderheiten der Android-Entwicklung einbeziehen und verwenden.\\
So muss man am Anfang der Entwicklung auswählen, welche Android-\ac{API} als Minimalvoraussetzung verwendet werden  und welche Version vorrangig unterstützt werden soll. Zweifellos ist es möglich die von dem Endgerät verwendete Android-Version abzufragen und dementsprechend die Funktionalität der App anzupassen.
Zudem können \textit{Java-Packages} eingebunden und verwendet werden, um bekannte Funktionen auch in C\# verwenden zu können.\\
Eine weitere Entwickler-Unterstützung ist das automatische Führen des Android-Manifestes. Dabei werden zwar nur rudimentäre Einstellungen aus der Entwicklung übernommen, aber auch diese Unterstützung ist für Neulinge auf dem Gebiet der Android-Entwicklung eine Beihilfe.
\subsection{Android Emulator}
\label{ssec:xamarin-emulator}
Zum Testen der Android-App konnte ein Emulator verwendet werden, der in dem Xamarin-Plugin für \textit{Visual Studio} bereitgestellt wurde. Damit konnten dann verschiedene Szenarien, wie Verbindungsverlust oder Speicherknappheit, nachgestellt werden. Für die App wurde das Android-API-Level 19 als Minimal-Anforderung gewählt, da eine zeitnahe Android-Version verwendet werden sollte. Das \textit{Target}-Level wurde auf das API-Level 21 gesetzt. Dies steht für Android 5.0 mit dem Namen Lollipop.\footcite{Xamarin-API}
\section{Eigene Umsetzung}
\label{sec:nat-umsetzung}
Im Folgenden wird auf die Umsetzung der nativen Android-Applikation, mit Hilfe von Xamarin Platform, eingegangen. Anfangs wurde beim Anlegen des Projektes das Android-API-Level, wie oben beschrieben, auf 19-21 gesetzt und die Entwicklung darauf abgestimmt.

\subsection{Anlegen der Layouts}
\label{ssec:nat-layouts}
Es müssen verschiedene \textit{Views} angelegt werden. Darunter sind Login-Fenster, Übersichtsseiten, die die Trainingspläne und Übungen anzeigen, und eine Seite zum Eintragen von Trainingsdaten.\\
Beim Aufbau der Oberflächen sind die Schritte eindeutig identifizierbar, da diese Prozedur für alle \textit{Layouts} gleich abgehandelt werden sollte.\\
Zuerst wird ein \textit{Layout} angelegt und die Bedienelemente (\textit{Widgets}) darauf angeordnet. Dazu kann man \textit{ViewGroups} zur Gruppierung verwenden und die Ausrichtung auf dem Fenster wird mit Hilfe von \textit{Layouts} möglich.\footcite[Vgl. S. 58ff.]{Android-BeckerPant}\\
Probleme entstanden dabei jedoch nur manchmal bei der Ausrichtung von \textit{Widget}-Elementen, die aber zügig gelöst werden konnten.\\
Des Weiteren muss für die Oberfläche dann eine dazugehörige \textit{Activity} angelegt werden, die das Fenster aufruft und die Interaktionen hinter den \textit{Buttons} ausführt.\\
Zum Anzeigen der Login- und Registrieren-Oberflächen wurden Dialoge verwendet, um dem Benutzer zu zeigen, dass sich die Interaktion zum Anmelden vor dem Zugang zu der eigentlichen Applikation vollzogen werden muss.\\
Auf der Seite zur Registrierung sollen Daten über den Fitnesszustand, das Geschlecht und die körperliche Betätigung aus einer Auswahl wählbar sein. Dazu sollten dementsprechend \textit{Spinner}, scrollbare Auswahlfelder, verwendet werden. Dabei lag die Schwierigkeit jedoch in der Belegung mit den auswählbaren Werten. Diese mussten zuerst eingesetzt und dann nach der Übergabe an die \textit{Activity} wieder zurückformatiert werden. Es werden von der Oberfläche nämlich nur \textit{Strings} übergeben. 
Zur Aufnahme der Daten Geschlecht, Job und Beruf gibt es vorher definierte Daten für die Eingabe auf dem Server. Dabei hat sich anfangs die Schwierigkeit ergeben, dass die \textit{Spinner}, die scrollbaren Auswahlfelder, mit den festgelegten Daten besetzt und dann in dem entsprechenden Datentypen wieder ausgelesen werden müssen. Die Belegung der \textit{Spinner} erfolgt über einen typisierten \textit{ArrayAdapter}, der die Werte des übergebenen \textit{Enums} ausgibt. Das Einlesen des ausgewählten Wertes wird über jeweils eine ausgelagerte Funktion geregelt, die die Auswahl, die als \textit{String} erhalten wird, in den jeweiligen Typ überführt. Anhand der erhaltenen \textit{ServerException} wird dann ausgegeben, welche Eingabe für die Registrierung falsch eingegeben wurde. Dies ist auch einer der Gründe, weshalb die Registrierung nur im Online-Modus der App unterstützt wird. Zudem muss der Server überprüfen, ob der Benutzername verwendet werden kann.\\
Nach erfolgreicher Registrierung wird der Dialog wieder ausgeblendet und die Konnektivitätsanzeige der Startseite wird mit dem aktuellen Status belegt. Dies geschieht nicht beim Statuswechsel, da dies mit der Architektur der Online-Status-Abfrage in Verbindung steht. Diese wird in einem eigenen \textit{Thread} durchgeführt und dieser kann keine Änderungen an der Oberfläche vornehmen. Eine Verbesserungsmöglichkeit wäre deshalb ein Aufruf in dem Abfrage-\textit{Thread}, der dann auf dem \textit{UI-Thread} ausgeführt wird. Dann würde die Anzeige immer direkt beim Statuswechsel aktualisiert werden.\\
Beim Login wird die Kombination Benutzername und Passwort beim \textit{OnOffServiceLocal} abgefragt, wenn der \textit{Login-Button} betätigt wird. Bei einer ungültigen Eingabe wird ein Hinweis an dem Feld des Passwortes angezeigt, der angibt, dass die Login-Daten falsch sind und eine erneute Eingabe erforderlich ist. Aus Sicherheitsgründen wird nicht angegeben, ob der Benutzername schon nicht in der Datenbank vorhanden ist, oder, ob nur die Kombination fehlerhaft ist. Nach einer validen Eingabe wird der Login-Dialog ausgeblendet und es folgt eine Weiterleitung zu den Trainingsplänen des nun eingeloggten Benutzers.\\
Die Darstellung der Trainingspläne und der zugehörigen Übungen auf einer folgenden Seite sind technisch gesehen gleich. Einzig die Beziehung der zu ladenden Daten und die übergebenen Werte ändern sich. Es soll eine Auflistung der Daten geschehen, die es durch die Auswahl eines Listenfeldes ermöglicht, zur nächsten Seite weiterzuleiten. Als herausfordernd hat sich dabei das Belegen der \textit{ListView} zur Anzeige der tabellarischen Daten und die Weitergabe der \textit{ScheduleId} und der \textit{UserId} herausgestellt. Die \textit{ScheduleId} und die \textit{UserId} werden benötigt, um die Übungen zu einem Trainingsplan ermitteln zu können. Zuvor wurde die \textit{ListView} erstellt. Dafür sind ein \textit{ScheduleListViewAdapter} und ein \textit{ScheduleView} von Nöten. Der \textit{ListViewAdapter} erweitert die Klasse \textit{BaseAdapter} und gibt bei einem Klick die Position des Elements im \textit{Array} der Trainingspläne zurück. Das unsichtbare Feld \textit{txtScheduleViewID} im \textit{ScheduleView} ist notwendig, um dieses bei einem Klick auslesen zu können und dann an die folgende Übersichtsseite der Übungen übergeben zu können.\\
Zu Anfang wurde vergeblich versucht, die \textit{UserId} und die \textit{ScheduleId} über den Aufruf der \textit{ExerciseActivity} mit zu übergeben. Diese Möglichkeit hat sich im Nachhinein als Fehler herausgestellt und eine weitere Einarbeitung in die vorherig erläuterten \textit{Intents} (siehe Kapitel \ref{ssec:android-activities}) durchgeführt. Danach wurde die Umsetzung dahingehend fortgeführt, dass die Funktion \textit{PutExtra()} des \textit{Intents} dazu genutzt wurde, Daten zu übertragen. In der \textit{ExerciseActivity} werden diese dann wieder ausgelesen und weiterverwendet. Beide Werte sind essentiell, um die Übungen des angemeldeten Benutzers zu seinem ausgewählten Trainingsplan zu erhalten.\\
\lstinputlisting[caption=Übertragen von Daten zwischen Activities, label=lst:ExerciseActivity, style=sharpc]{content/listings/ExerciseActivity.cs}
Bei der Übergabe der Daten an die \textit{PracticeActivity} wird zudem noch die \textit{ExerciseId} übertragen, um alle nötigen Fremdschlüssel für das Anlegen des Trainings zu besitzen.\\
Eine Anmerkung zu der Übergabe der \textit{UserId}: Diese muss über die \textit{Activities} übertragen und kann nicht einfach aus der aktuellen \textit{UserSession} des Benutzers gelesen werden, da man davon ausgehen muss, dass sich der Benutzer auch offline einloggen kann. Demnach hat man im Online-Modus zwei Möglichkeiten die \textit{UserId} zu erhalten, im Offline-Modus hingegen ist dies die einzige Lösung.\\
\lstinputlisting[caption=Auslesen von Daten zwischen Activities, label=lst:PracticeActivity, style=sharpc]{content/listings/PracticeActivity.cs}
Wie im Codebeispiel \ref{lst:PracticeActivity} ersichtlich, kann man die übergebenen Informationen zwischen \textit{Activities} aus dem \textit{Intent} auslesen. Zudem kann man erkennen, dass man dank Xamarin das \textit{Parsen} einer \textit{Integer}-Zahl über eine \textit{Java}-Funktion durchführen kann (zu sehen im Codebeispiel \ref{lst:PracticeActivity} Zeile 9).\\
\subsection{OnOffService}
\label{ssec:nat-onoffservice}
Dieser \textit{OnOffService} ist die Schicht zum Verteilen der An- und Abfragen, abhängig von dem Verbindungsstatus. Demnach werden immer Methoden dieser Klasse von den \textit{Activities} aufgerufen, wenn Daten abgerufen oder abgelegt werden sollen. Dann wird in der Methode eine Unterscheidung gemacht, ob das Endgerät gerade online oder offline ist und dementsprechend die Interaktion mit der lokalen Datenbank (siehe Kapitel \ref{ssec:nat-db}) oder dem Server durchgeführt. Zudem wurde dabei immer die Konvertierung verschiedener Typen durchgeführt, die durch die Architektur nötig wurden.
\lstinputlisting[caption=Login über den \textit{OnOffService}, label=lst:OnOffService, style=sharpc]{content/listings/OnOffService.cs}
In diesem Codebeispiel kann man die Umsetzung dieser Aufgabe anhand des Logins erkennen. Zum Aufbau der lokalen Datenhaltung wird in diesem Schritt schon der \textit{User}, der sich gerade einloggt, mit der \textit{UserId} gespeichert. Die \textit{Exceptions} werden bewusst nicht in diesem Schritt behandelt, um der aufrufenden \textit{Activity} die originalen Fehlermeldung des Servers übergeben und den Fehler dann in der Oberfläche darstellen zu können.\\
Alle Methoden der Klasse \textit{OnOffService} sind asynchron. Das liegt zum einen an den asynchronen Aufrufen, die an den Server gestellt werden. Diese ermöglichen es, dass Aufgaben gestartet werden können und zu einem späteren Zeitpunkt auf die Ergebnisse zugreifen zu können. Dadurch werden die asynchronen Aufgaben ausgelagert und entlasten den \textit{Main-Thread}. Deshalb würde es die Performancevorteile verspielen, wenn man diese asynchronen Methoden dann beim Serverabruf synchron verwenden würde. Auch wenn dabei noch Verbesserungen in der App vorgenommen werden können, um die Ressourcen des Gerätes optimal auszunutzen. Unter Verwendung eines eigenen \textit{Threads} zum Abarbeiten der Server-Anfragen könnten weitere Leistungssteigerungen erreicht werden. Dabei wurde dann aber der Aufwand und die Probleme der \textit{Thread}-Synchronisierung als ein für diese Arbeit zu großer Aufwand geschätzt. Besonders, da die Server-Methoden großteils Rückgabewerte liefern, die für die Weiterverarbeitung essentiell sind. Möglich wäre eine Optimierung mit einem startenden \textit{Thread} in den Server-Aufrufen, die dann neben dem \textit{UI-Thread} laufen und bei Fertigstellung die benötigten Daten wieder in den startenden \textit{Thread} übertragen. Damit würde man eventuelle Ladezeiten der Oberfläche minimieren oder sogar vollständig verhindern.

\subsection{Lokale Datenbank}
\label{ssec:nat-db}
Technologisch wird eine SQLite-Datenbank aus den bereits in Kapitel \ref{ssec:android-sqlite} erläuterten Vorteilen genutzt.\\
Die lokale Datenbank dieser App wird für die Umsetzung des \textit{Caches} (siehe Kapitel \ref{ssec:nat-cache}) benötigt. Darin werden die lokalen Daten gespeichert und mit dem Server abgeglichen.
Die Erstellung der Datenbank findet beim Start des \textit{OnOffServices} statt. Zur Verbesserung der Leistung wird die Erstellung in einem separaten Thread durchgeführt, da kein Rückgabewert erwartet wird und der \textit{Main-Thread} so entlastet wird. Die zur Erstellung der Server-Datenbank verwendeten Models konnten in diesem Zusammenhang nicht verwendet werden, da die Annotation der OR-Mapper nicht äquivalent sind. Des Weiteren ist es nicht möglich Fremdschlüssel in SQLite zu deklarieren. Diese wurden nun programmatisch oder über Beziehungstabellen gepflegt. Daraus ergibt sich eine Verbesserungsmöglichkeit für eine neue Version der Applikation. Als hilfreich könnte sich dabei eine \textit{SQLite-Extension} herausstellen, die der Datenbank dann einen größeren Funktionsumfang bereiten und die Anzahl der direkten SQL-Befehle minimieren würde. Diese wurde testweise eingepflegt, funktionierte aber nicht erwartungsgemäß.\footcite{Android-SQLiteExtension}\\
\lstinputlisting[caption=\textit{UserModel} für die lokale Datenbank, label=lst:DBModels, style=sharpc]{content/listings/DBModels.cs}
Der lokale \textit{User} (Quelltext \ref{lst:DBModels}) besitzt eine lokale Id als \textit{PrimaryKey} zur Identifizierung. Geplant war im Vorfeld jedoch eine Kombination aus \textit{wasOffline} \textit{LocalId}. Da SQLite jedoch keinen \textit{PrimaryKey} aus zwei Attributen unterstützt, musste dieser Plan verworfen werden. Die gespeicherte \textit{UserId} ist der Guid vom Server, der als \textit{Session}-Ersatz gehalten wird. Die anderen benötigten Tabellen werden nach diesem Muster auch erstellt.\\
Die Interaktion mit der lokalen Datenbank wird synchron durchgeführt, da die asynchrone Schnittstelle nicht alle benötigten Methoden zur Verfügung stellt. Beim Zugriff zur Datenbank wird auf eine Mischung aus direkten SQL-Befehlen und der Nutzung von SQLite-Methoden zurückgegriffen.\footcite[Vgl.]{Android-SQLiteORM} Einfache Such- oder Einfüge-Operationen werden vom \textit{Framework} bereitgestellt, wohingegen Abfragen über die erstellten Beziehungstabellen selbst umgesetzt wurden.
\subsection{ManagementService}
\label{ssec:nat-ManagementServiceLocal}
Die Verbindung zum Server geschieht über das bereitgestellte \textit{Package} \linebreak \textit{fIT.WebApi. Client.Portable}. Alle benötigten Funktionen werden darin bereitgestellt. Damit wird dann die Kommunikation über REST mit dem Server abgewickelt.\\
In der App wird der \textit{ManagementService} zum Verbindungsaufbau verwendet. Da ein internes Routing über den \textit{OnOffService} durchgeführt wird, die Verbindung zur lokalen Datenbank von der \textit{LocalDB} gemacht wird, gibt es zur Verbindung mit dem Server den \textit{ManagementLocalService}. Dieser \textit{Service} arbeitet mit dem Server direkt zusammen und ist ausschließlich für das Abrufen von Daten vom Server verantwortlich. Rückgabewerte und Fehler werden meist einfach weitergereicht.\\
Zur Veranschaulichung ein kleiner Ausschnitt aus dem Online-Login, der veranschaulicht, wie die Kommunikation aufgebaut wird.
\lstinputlisting[caption=Login am Server, label=lst:ManagementServiceLocal, style=sharpc]{content/listings/ManagementServiceLocal.cs}
\subsection{Verbindungsprüfung zum Server}
\label{ssec:nat-konnektivität}
Die Verbindungsprüfung zum Server geschieht im \textit{OnOffService}. Dafür wird eine Endlosschleife in einem eigenen \textit{Thread} gestartet, um in einem festen Intervall (alle 10 Sekunden) einen Ping-Befehl zum Server zu schicken und damit die Erreichbarkeit des Servers zu überprüfen. Diese Methode wird vom \textit{ManagementService} des eingebundenen \textit{Packages} bereitgestellt. Das Zeitintervall könnte durch Tests noch feiner eingestellt werden, um mit einem aktuelleren Status intern arbeiten zu können.
\lstinputlisting[caption=Verbindungsüberprüfung, label=lst:ConnectivityCheck, style=sharpc]{content/listings/ConnectivityCheck.cs}
Als elegante Möglichkeit zur Überprüfung, ob eine Verbindung zum Internet besteht, hätte auch eine interne Android-Funktion zur Überprüfung der \textit{InternetConnectivity} ausgereicht. Da aber auch davon ausgegangen werden muss, dass der Server nicht erreichbar ist, die Internetverbindung jedoch noch, könnte besonders dieses Szenario dann eine Reihe von Fehlern verursachen. Deshalb wird die einfach Überprüfung mit Hilfe eines regelmäßigen Ping-Befehls präferiert.\\
Eine Verbesserung dieses Algorithmus liegt in dem Blockieren des Pings, um den sehr unwahrscheinlichen Fall eines \glspl{Dirty Read} auf die \textit{Online}-Variable zu vermeiden. Da dieser Fehlerfall als irrelevant eingestuft wurde, wurde diese Umsetzung niedriger priorisiert.
\subsection{Umsetzung des Caches}
\label{ssec:nat-cache}
Der \textit{Cache} (siehe Kapitel \ref{sec:cache-definition} zur Definition) ist im Fall dieser nativen \gls{App} ein Zusammenschluss mehrerer im Vorfeld genannter Komponenten und Funktionen. Zum einen wird die Datenhaltung des \textit{Caches} über die lokale Datenbank geregelt, die Verbindungsüberprüfung aus dem vorherigen Artikel wird für die Entscheidung des Verbindungsstatus verwendet. Insgesamt findet sich der \textit{Cache} in der gesamten Logik der \gls{App} wieder. So werden die Daten in der lokalen Datenbank aktualisiert, falls im Online-Modus Daten abgefragt werden. Diese werden dann mit den lokalen Daten abgeglichen und bei Bedarf aktualisiert (siehe Abbildung \ref{pic:nat-CRUD}).\\
%Sequenzdiagramm-CRUD
\begin{figure}[!h]
\centering
\includegraphics[width=\linewidth]{content/images/fITNat-OnOff-CRUD}
\caption{Sequenzdiagramm CRUD}
\label{pic:nat-CRUD}
\end{figure}
Die Hauptfunktionalität und -schwierigkeit lag in dem Szenario, dass die App gerade wieder eine Verbindung zum Server aufbaut und im Vorfeld Daten im Offline-Modus gespeichert hat, die dem Server noch nicht bekannt sind. Dieser Fall ist in dem Codeausschnitt \ref{lst:ConnectivityCheck} zu sehen. Dabei wird überprüft, ob die App in dem vorherigen Intervall noch im Offline-Modus war. 
\lstinputlisting[caption=Synchronisation der Offline-Daten, label=lst:Sync, style=sharpc]{content/listings/Sync.cs}
Ist dem so, wird in der lokalen Datenbank nach Trainings gesucht, die offline angelegt wurden. Diese werden dann mit dem Server abgeglichen und hochgeladen. Das Hochladen geschieht einzeln, damit im Fall eines abrupten Verbindungsverlustes maximal ein Datensatz verloren geht. Dabei wäre es möglich eine Transaktionsverwaltung für die Verbesserung zu integrieren, um dieses Problem zu verhindern. Bei dem Anlegen des Trainings fällt auf, dass die Attribute Benutzername und Passwort noch einmal übergeben werden. Diese Maßnahme musste ergriffen werden, um eine Verbindung zum Server herstellen zu können. Dazu wird eine \textit{Session} benötigt, die vorher noch nicht besteht, für den \textit{Upload} aber essentiell ist. Somit wird die \textit{Session} vor dem Hochladen abgerufen.