\chapter{Realisierung der serverseitigen Implementierung}
\label{cha:server-impl}
In diesem Kapitel wird näher auf die Implementierung des in Kapitel \ref{cha:architektur} besprochenen Webservices eingegangen. Es enthält eine Übersicht über die genutzten Komponenten und die konkreten Techniken, welche für die Implementierung genutzt wurden. Anschließend werden nochmal besonders auf Sicherheitsaspekte in Verbindung mit RESTful-Architekturen eingegangen. Die WebApi kann über die URL\\ \href{http://fit-bachelor.azurewebsites.net/}{http://fit-bachelor.azurewebsites.net/} erreicht werden. 
\section{Was ist ein Webservice?}
\label{sec:definition-webservice}
Um verteilte Systeme aufzubauen ist es nötig, eine Struktur zu implementieren, mit der Maschinen untereinander kommunizieren können. Diese Aufgabe übernehmen Webservices. Sie stellen innerhalb eines Netzwerkes Schnittstellen bereit, damit Maschinen plattformübergreifend Daten austauschen können. Hierbei wird meistens HTTP als Träger-Protokoll genutzt um eine einfache Interoperabilität zu gewährleisten.\footcite{Definition-Webservice} Die dabei angeforderten Daten werden in der Regel im XML- oder JSON-Format übermittelt. 
\subsection{RESTful Webservices}
\label{sec:definition-rest}
Da Webservices in der Regel \ac{HTTP} als Protokoll verwenden, wurde die Idee zur Implementierung eines Webservices erweitert, um die Möglichkeiten des Protokolls vollständig zu benutzen. Heraus kam das Programmierparadigma REST (\textit{Representational State Transfer}). Mit einem REST-Server bzw. einem RESTful Webservice bezeichnet man einen Webservices, welcher die strikte Nutzung von HTTP als Programmierparadigma umsetzt.  Dies meint, dass sich, wie im Internet üblich, hinter einer \ac{URI}, genau eine einzige Ressource verbirgt. Bei einer Ressource geht man von Daten aus. Im Gegensatz zu anderen Webservice-Implementierungen stellen RESTful Webserver keine Methoden oder aufrufbare Funktionalitäten zu Verfügung. Diese Daten werden vom REST-Service über eine eindeutige URL bereitgestellt. Dies hat den Vorteil, dass die Schnittstele leicht und eindeutig beschrieben werden kann, da ein Aufruf einer URL an den REST-Service immer die gleichen Daten liefert. \\
In den meisten Fällen, wie auch in den Anwendungsfällen dieser Arbeit, soll der Webservice \ac{CRUD}-Funktionalitäten bereitstellen. Damit die Schnittstelle nicht durch unnötig viele unterschiedliche URLs aufgebläht wird, sieht der RESTful-Ansatz die Verwendung der verschiedenen HTTP-Verben vor. Hierbei werden zwei Arten von URLs unterschieden, um in Kombination mit HTTP-Verben verschiedene Aufgaben zu erfüllen. Zur Veranschaulichung sollen uns folgende zwei URLs dienen:
\begin{itemize}
\item http://myRestService.de/Schedule
\item http://myRestService.de/Schedule/123
\end{itemize}
Es fällt auf, dass die beiden URLs sich bis auf das letzte Segment unterscheiden. Im ersten Fall wird die URI als Collection URI bezeichnet, da hiermit die Gesamtheit aller Trainingspläne angesprochen wird. Im zweiten Fall wird die ID einer Trainingsplans benutzt und mit einen konkreten Trainingsplan zu interagieren. Man spricht hier von einer Element URI.\footcite[S. 12ff.]{Building-a-REST-Service}

Um den Rahmen der Arbeit nicht zu sprengen, wird sich hier nur auf die Vorstellung der vier meistverwendeten HTTP-Verben beschränkt:\\
Das Verb GET ruft eine Ressource vom Server ab, wobei diese nicht verändert wird. Bei Nutzung einer Collection URI, werden alle Einträge dieser Entität als Verbundstruktur abgerufen. Jedes Element der Struktur beinhaltet die Element URI auf das konkrete Element. Wird GET auf eine Element URI aufgerufen, wird das konkrete Element aufgerufen. Hierbei antwortet der Server dem HTTP-Standard folgend mit dem Status-Code 200 bei erfolgreicher Suche oder 404, wenn keine Ressource gefunden wurde.\\
Das POST wird zur Erstellung neuer Inhalte verwendet. Bei Nutzung von Element URIs wird versucht die ID für das neue Element zu benutzten. In der Regel wird das ID Mamagement aber auf dem Server implementiert, so dass in der Regel eine Collection URI zur Erstellung von Elementen zum Einsatz kommt.\\
Mit dem HTTP-Verb PUT wird eine vorhandene Ressource geändert oder hinzugefügt. Obwohl es REST-conform wäre, eine Collection URI per PUT aufzurufen, wird dies selten Implementiert, da der normale Anwendungsfall ist, dass ein einzelnes Objekt geändert werden soll. Stattdessen wird sich auf Element URIs beschränkt. Ist eine Ressource mit der übergebenen ID nicht vorhanden, wird je nach Implementierung entweder ein neues Objekt mit der ID erstellt (Statuscode 201 (Created)) oder die Verarbeitung verweigert. Der Server gibt dann den Statuscode 400 (Bad Request) oder 404 (Not found)  zurück. \\
Das letzte HTTP-Verb, welches hier vorgestellt werden soll, ist DELETE. Wie der Name vermuten lässt, wird damit eine Ressource vom Server entfernt. Wie auch bei PUT wird in der Regel auf eine Implementierung von DELETE als Collection URI verzichtet, da sonst alle Einträge einer Entität gelöscht werden können. Im Erfolgsfall wird mit dem Statuscode 200 (OK) geantwortet und bei Fehlern mit 400 (Bad Request) oder 404 (Not found).

Da das statuslose Protokoll HTTP zum Datenaustausch genutzt wird, muss ein RESTful Webservice so implementiert werden, dass alle Informationen, welche für die Kommunikation benötigt werden, bei jeder Kommunikation mitgesendet werden. Was vordergründig als Nachteil erscheint ist ein wesentlicher Vorteil. Dadurch, dass jeder Request alle nötigen Informationen mitliefert, ist es nicht nötig, Sitzungen auf dem Server zu verwalten. Dadurch kann ein RESTful Webservice sehr leicht skaliert werden.

Das RESTful-Paradigma besagt, dass Daten losgelöst von einer Repräsentation bereit gestellt werden. Darum ist ein RESTful Webservice so zu implementieren, dass der Client das gewünschte Datenformat anfragen kann. Bei Nutzung des Protokolls HTTP wird dies in der Regel über die Header-Eigenschaft \textit{accept} realisiert, welche gewünschten Datenformate angibt. Wird dieses nicht vom Server unterstützt, werden die angeforderten Daten in einem Standard-Format zurückgegeben. \footcite[S. 26ff.]{REST-und-HTTP}
\section{Aufbau der Komponenten}
\label{sec:aufbau-Komponenten}
In diesem Kapitel wird beschrieben, wie der zuvor theoretisch beschriebene REST-Ansatz für das Projekt umgesetzt wurde. Der Server besteht aus zwei Teilen: Der Datenbank und der WebApi, welche jeweils gesondert vorgestellt werden.\\
Die WebApi wurde nach dem Design-Pattern \ac{MVVM} aufgebaut. Hierbei dienen die Objekte, welche aus Tupeln der Datenbank erstellt werden als Model-Klassen. Bevor diese Daten dann über WebApi ausgespielt werden, werden sie vom Model in ein ViewModel übertragen. Durch diese Kapselung kann, im Sinne des Design-Pattern Hierbei wird nach dem Grundgedanken des \ac{Seperation of Concerns}, klar zwischen den Models für die Datendank und den ViewModels, welche die WebApi benutzt, unterschieden werden. 
\subsection{Aufbau der Datenbank}
\label{ssec:aufbau-server-db}
Da bei der Umsetzung des Projekts konsequent auf Produkte von Microsoft gesetzt wurde, wurde als Datenbanksystem MS SQL gewählt. Dies hat den den Vorteil, dass das \ac{Microsoft Entity Framework} als \ac{OR-Mapper} genutzt werden kann. Dieser Bietet das Design-Pattern \textit{Code First}. Das bedeutet, dass anhand präparierter Model-Klassen die benötigten Relationen ((Richtiges Wort?!))in der Datenbank automatisch erzeugt wird. \footcite{entity-framework-code-first}\\
An den folgenden Bespielen wird exemplarisch beschrieben, wie die Model-Klassen aufgebaut wurden und wie sich daraus die Struktur der Datenbank ergibt. Grundlage für Datenbankklassen ist das Interface IEntity(Quellcode \ref{lst:IEntity}):
\lstinputlisting[caption=Basisinterface für DB-Repräsentationen, label=lst:IEntity, style=sharpc]{content/listings/IEntity.cs}
Das Interface gewährleistet, dass jede Datenbank-Entität einen eindeutigen Schlüssel besitzt.
Eine konkrete Implementierung für eine Model-Klasse sieht man im Quellcode-Beispiel \ref{lst:Schedule}, in der die Trainingspläne implementiert sind:
\lstinputlisting[caption=Modelklasse für Trainingspläne, label=lst:Schedule, style=sharpc]{content/listings/Schedule.cs}
Hierbei zeigt sich gut, was mit einer präparierten Klasse gemeint ist. Über die Annotation \textit{Required} wird definiert, dass die Eigenschaft \textit{Name} zwingend bei Insert- und Update-Operationen gesetzt werden muss. \\
Gleichzeitig sieht man an diesem Beispiel gut, wie das Entity Framework über Namenskonventionen Verbindungen zwischen Entitäten auflöst. Auf Grund des Aufbaus der Klasse \textit{Schedule} wird eine \ac{einwertige Fremdschüssel}-Beziehung zu der Model-Klasse \textit{User} erzeugt, da folgende Bedingungen erfüllt sind:
\begin{itemize}
\item Die Klasse \textit{User} besitzt eine Eigenschaft \textit{ID} vom Datentyp \textit{string}
\item Die Klasse \textit{Schedule} besitzt eine Eigenschaft \textit{UserID} vom Datentyp \textit{string}
\end{itemize}
Auch die Erstellung einer \ac{mehrwertigen} Beziehung lässt sich aus dem Code-Beispiel \ref{lst:Schedule} ablesen: Da es eine Entität gibt, welche Exercise heißt und die Model-Klasse \textit{Schedule} eine Verbundstruktur besitzt, welche \textit{Exercises} heißt, wird implizit eine Verbindung zwischen den Relationen in der Datenbank angelegt. \footcite{entity-framework-code-first}
\subsection{Aufbau der WebApi}
\label{ssec:aufbau-webapi}

Zur Umsetzung der REST-Schnittstelle wurde mit Hilfe des Microsoft-Frameworks \ac{ASP.NET Web API 2} umgesetzt. Dieses ermöglicht es, Controller-Methoden zu schreiben, welche über definierte Routen per HTTP aufgerufen werden können. Hierbei wurde wird die Umsetzung im Sinne des Rest-Paradigmas durch vorhandene Funktionen unterstützt.\footcite[S. 2ff.]{Building-a-REST-Service}\\
Dies wird im Code-Beispiel \ref{lst:ScheduleController} gezeigt:
\lstinputlisting[caption=POST-Methode zur Erstellung eines Trainingsplans, label=lst:ScheduleController, style=sharpc]{content/listings/SchedulesController.cs}
Hierbei fällt sofort auf, dass das WebApi-Framework die Nutzung von Annotationen fördert: Das Routing kann durch die Annotationen \textit{Route} (Zeile \ref{line:SchedulesController_Route}) an der Methode und \textit{RoutePrefix} (Zeile \ref{line:SchedulesController_RoutePrefix}) am gesamten Controller konfiguriert werden. Neben der Konfiguration der Route muss dem Framework noch mitgeteilt werden, welche HTTP-Verben in dieser Methode zulässig sind. Das WebApi-Framwork bietet hierfür pro Verb eine eigene Annotation. Im Codebeispiel \ref{lst:ScheduleController} wird über die Annotation \textit{HttpPost} (Zeile \ref{line:SchedulesController_HTTPVerb}) ausgesagt, dass nur POST-Request durch diese Methode verarbeitet werden\footcite{webApi-AttributeRouting}. \\
Das Framework versucht die empfangenen Daten in einem ViewModel-Object zu kapseln. Dabei werden die Daten validiert. Die dafür genutzten Validatoren werden direkt im View-Model als Annotationen angegeben.\footcite{webApi-Validation} Die Klasse \textit{EntryModel} (Beispiel \ref{lst:EntryModel}) zeigt die Möglichkeit in Zeile 7 und 11. \\ 
Schlägt die Validierung fehl, werden die Fehler mit dem passenden Statuscode zurückgegeben. Andernfalls werden die Daten per \ac{Factory}-Klasse in ein Model konvertiert und per \ac{Repository}-Klasse in der Datenbank persistiert. Anschließend wird dem Viewmodel, im Sinne des REST-Gedankens, ein URL zur GET-Methode mit der ID des neu erstellten Objekts übergeben. 
\lstinputlisting[caption=Basis-Model-Klasse, label=lst:EntryModel, style=sharpc]{content/listings/EntryModel.cs}

\subsubsection*{Swagger}
\label{sssec:Swagger}
Da die WebApi parallel zu Clients entwickelt wurde, wurde schnell die Notwendigkeit einer Dokumentation des aktuellen Stands nötig. \\
Aus diesem Grund wurde Swagger in die WebApi integriert. Swagger ist ein quelloffenes Framework zur Dokumentation von RESTful WebApis, welche von vielen großen Konzernen genutzt wird\footcite{swagger}. Durch Nutzung des \ac{NuGet}-Packets \textit{Swashbuckle} konnte durch hinzufügen von Kommentaren und Annotationen eine vollständige und übersichtliche Dokumentation erstellt werden\footcite{implementing-Swagger}. \\
Da das Authorisierungsprotokoll OAUTH in Version 2 zum Durchführungszeitpunkt des Projekts noch nicht von Swagger unterstützt wird, kann das Ausführen von API-Request aus Swagger heraus nur für Methoden durchgeführt werden, für die keine Autorisierung des Nutzers benötigt wird. \\
Die Dokumentation ist unter \href{http://fit-bachelor.azurewebsites.net/swagger}{http://fit-bachelor.azurewebsites.net/swagger} aufrufbar. 
\begin{figure}[h]
\centering
\includegraphics[width=0.8\linewidth]{content/images/Swagger-UI-fIT}
\caption{Screenshot: Swagger UI der Web Api}
\label{pic:swagger-UI}
\end{figure}
\section{Authentifizierung \& Autorisierung}
\label{sec:server-authorisierung}

\subsection{OAuth2}
\label{ssec:oauth2}

\subsection{JWT and Bearer Token}
\label{ssec:jwt-bearer}

\subsection{Zugriff per CORS}
\label{ssec:cors}